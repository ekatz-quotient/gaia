<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>GAIA</title>
        <meta http-equiv="Content-Type" content="text/html;"/>
        <meta charset="utf-8"/>
        <link rel='stylesheet' type='text/css' href="https://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic"/>
        <link rel="stylesheet" type="text/css" href="doxygen.css" title="default" media="screen,print" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="https://rawcdn.githack.com/doxygen/doxygen/5213707f485360bd9145beebe2fab250ca133a02/templates/html/dynsections.js"></script>
    </head>
    <body>
        <div id="banner-container">
            <div id="banner">
                <span id="gaia">GAIA 0.1.0</span>
            </div>
        </div>
        <div id="content">
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Introduction to Gaia MR </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Overview </h2>
<p>A C++ Gaia MR program will usually be composed of three types of objects (note that all of these have the same C++ type, PTable): readers, mappers, and joiners.</p>
<p>A reader is responsible for reading input files of a specific type, it is usually initialized via a glob URL and a format, possibly including some metadata.</p>
<p>A mapper runs a mapping function on each input it gets, outputting one or more values per input. Mappers also shard the data according to a sharding function, allowing a joiner to apply a function to all inputs that it gets under the same shard.</p>
<p>A joiner runs on every shard, reading the output from all mappers that outputted to it and later outputs some values based on what it read.</p>
<p>The above descriptions are pure idealized descriptions. In real life, both mapper and joiner are stateful, both support outputting values both during shard finish and for every input that they get, and both can shard their outputs. This means that mapper and joiner can likely be easily generalized into one type of object.</p>
<p>Furthremore, both mapper and joiner support writing to counters and frequency maps. Counters are key-value maps that are used to collect statistics per object. They are outputted to logs and possibly to online monitoring. Frequency maps act as a global shared state, shared between all threads and <em>MR phases</em>. This means that one can update the frequency map in one phase and read the updates in another.</p>
<h2>Example (code simplified from <code>word_count.cc</code>) </h2>
<p>Create a pipeline object.</p>
<div class="fragment"><div class="line">PipelineMain pm(&amp;argc, &amp;argv);</div><div class="line">Pipeline* pipeline = pm.pipeline();</div></div><!-- fragment --><p>Read the wanted inputs.</p>
<div class="fragment"><div class="line">std::vector&lt;std::string&gt; inputs;</div><div class="line">// some code here should fill inputs.</div><div class="line">PTable&lt;std::string&gt; read = pipeline-&gt;ReadText(&quot;inp1&quot;, inputs);</div></div><!-- fragment --><p>For every input, convert it into word-count pairs, shard outputs by word. <code>WordSplitter</code> is a class that implements the map operation. Note how <code>Map</code> is called from the <code>read</code> object, connecting the map operation with the inputs read earlier.</p>
<div class="fragment"><div class="line">PTable&lt;WordCount&gt; intermediate_table = read.Map&lt;WordSplitter&gt;(&quot;word_splitter&quot;, db);</div><div class="line">intermediate_table.Write(&quot;word_interim&quot;, pb::WireFormat::TXT)</div><div class="line">    .WithModNSharding(FLAGS_num_shards,</div><div class="line">                      [](const WordCount&amp; wc) { return base::Fingerprint(wc.word); })</div><div class="line">    .AndCompress(pb::Output::ZSTD, FLAGS_compress_level);</div></div><!-- fragment --><p>At this point, it is guaranteed that all instances of a word-count pair for the same word will appear in the same shard. This means that if we sum counts all over a shard, for every shard, we will get only one word-count pair per word, thus getting the correct counts. <code>WordCount</code> is a class that implements the join operation. Note how <code>Join</code> accepts a list of bindings to mappers, this can be used to connect an arbitrary number of mappers to a single joiner.</p>
<div class="fragment"><div class="line">PTable&lt;WordCount&gt; word_counts = pipeline-&gt;Join&lt;WordGroupBy&gt;(</div><div class="line">    &quot;group_by&quot;, {intermediate_table.BindWith(&amp;WordGroupBy::OnWordCount)});</div><div class="line">word_counts.Write(&quot;wordcounts&quot;, pb::WireFormat::TXT)</div><div class="line">    .AndCompress(pb::Output::ZSTD, FLAGS_compress_level);</div></div><!-- fragment --><p>Run the pipeline.</p>
<div class="fragment"><div class="line">LocalRunner* runner = pm.StartLocalRunner(FLAGS_dest_dir);</div><div class="line">pipeline-&gt;Run(runner);</div></div><!-- fragment --><p>Let's take a look at how the mapper and the joiner are implemented. A mapper has a <code>Do</code> function that is called for every input (the first parameter). It also accepts a <code>DoContext</code> object which allows it to output data, and update counters (in this example, the <code>matched</code> counter) and frequency maps. A mapper can also have an <code>OnShardFinish</code> that is called once a mapper is done reading a shard. In the full version of <code>word_count.cc</code>, one can that when <code>FLAGS_use_combine</code> is on, <code>WordSplitter</code> uses internal state and a <code>OnShardFinish</code> to run some accumulation in memory before it outputs to disk, thus doing some of the joiner's job.</p>
<div class="fragment"><div class="line">void WordSplitter::Do(string line, DoContext&lt;WordCount&gt;* cntx) {</div><div class="line">  MatchData md{this, line.c_str(), cntx};</div><div class="line"></div><div class="line">  StringPiece line_re2(line), word;</div><div class="line"></div><div class="line">  while (RE2::FindAndConsume(&amp;line_re2, *re_, &amp;word)) {</div><div class="line">    OnMatch(0, word, cntx);</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line">void WordSplitter::OnMatch(unsigned int id, StringPiece word, DoContext&lt;WordCount&gt;* cntx) {</div><div class="line">  cntx-&gt;Write(WordCount{string(word), 1});</div><div class="line">  cntx-&gt;raw()-&gt;Inc(&quot;matched&quot;);</div><div class="line">}</div></div><!-- fragment --><p>A joiner's per-input function doesn't have a fixed name. Instead, it is bound using the <code>BindWith</code> call (see above). In this case, it is the function <code>OnWordCount</code> that is called per input. It stores the words in an accumulating on-memory table. The table is outputted by <code>OnShardFinish</code> which is called, just like in the mapper, once reading the entire shard is done. Note that by default, unlike a mapper, a joiner writes to a new shard with the same id as its input shard, although this can be changed.</p>
<div class="fragment"><div class="line">class WordGroupBy {</div><div class="line"> public:</div><div class="line">  void OnWordCount(WordCount wc, DoContext&lt;WordCount&gt;* context) {</div><div class="line">    word_table_.AddWord(wc.word, wc.cnt);</div><div class="line">  }</div><div class="line"></div><div class="line">  void OnShardFinish(DoContext&lt;WordCount&gt;* cntx) { word_table_.Flush(cntx); }</div><div class="line"></div><div class="line"> private:</div><div class="line">  WordCountTable word_table_;</div><div class="line">};</div></div><!-- fragment --><h2>What happens when one runs a pipeline </h2>
<p>When one calls the <code>Pipeline::Join</code> or <code>PTable&lt;T&gt;::Map</code> methods, a <code>PTable&lt;T&gt;</code> object is created, which is a wrapper around a <code>detail::TableImplT</code>. The <code>detail::TableImplT</code> is given a factory function which gets a <code>RawContext</code> (see below) and generates <code>HandlerWrapperBase</code> objects. These objects represent the interface between executors (the classes which run join/map logic, see below) and the user-provided code. The three main interfaces provided by <code>HandlerWrapperBase</code> are: <code>SetGroupingShard</code> which calls the user provided <code>OnShardStart</code>, <code>Get(i)</code> which returns the i-th user-provided input handler for a join or the <code>Do</code> method of a map, and <code>OnShardFinish</code> which calls the user-provided function of the same name.</p>
<p>When one calls the <code>PTable&lt;T&gt;::Write</code> method, it adds the mapper/joiner into <code>Pipeline::tables_</code>. Mapper/joiners are translated into a protobuf based representation, discarding template magic. When one calls <code>Pipeline::Run</code>, it begins iterating on <code>tables_</code>, creating and running an executor object (<code>JoinerExecutor</code> or <code>MapperExecutor</code>) for each entry, and merging together several per-thread counters and frequency.</p>
<p>The executor object is responsible for the actual execution of the joiner/mapper. Before talking about executors, it is important to discuss the idea of an <code>IoContextPool</code>. In essence, an <code>IoContextPool</code> is an object that creates a thread pool where each thread is pinned to a single CPU. On these threads there is also an event loop, allowing several fibers (cooperative sub-threads) to run. The event loop in each thread waits for lambdas to be sent to it to run. Executors use this object in order to parallelize the work-load in an efficient, context-switchless way.</p>
<p>A <code>MapperExecutor</code> creates 2 fibers per thread, the first (<code>IOReadFiber</code>) is responsible for reading the data (either input data or output data from a previous mapper/joiner) and the second (<code>MapFiber</code>) is responsible to repeatedly call the <code>Do</code> function on the mapper. The two fibers communicate via a queue object (<code>record_q</code>).</p>
<p>A <code>JoinerExecutor</code> creates a single fiber <code>ProcessInputQ</code> per thread which constantly alternates between reading from a file and calling the callback. Note that this is less efficient than the 2 fibers of <code>MapperExecutor</code> and in the future may be replaced (or even better, unified with <code>MapperExecutor</code>). The <code>JoinerExecutor</code> also makes sure to read all of the files from mapeprs of the same shard before calling <code>OnShardFinish()</code>.</p>
<p>Some forms of IO storage (for example, Google Storage) work better when you read simultaneously instead of serially. Because of this, <code>MapperExecutor</code> allows one to duplicate the number of fibers it creates via <code>FLAGS_map_io_read_factor</code>. This flag's value is by default 2, which means that the previous paragraph was not accurate, <code>MapperExecutor</code> actually opens 4 fibers per thread, two <code>IOReadFiber</code>s and two <code>MapFiber</code>s (note that there's still a 1:1 messaging relationship between an <code>IOReadFiber</code> and a <code>MapFiber</code>).</p>
<p>Note that the idealized model of a thread per CPU doesn't actually work on Linux when reading files from local disk. Linux doesn't support async IO for any filesystem that is not XFS. Because of this, there is a separate pool of threads that only run IO calls and send their results to the caller. This problem doesn't exist when working with Google Storage, since Asio is capable of handling asynchronous network IO.</p>
<p>Although both types of executors handle the logic of the mapping/joining process, they avoid interacting with the external environment directly. Instead, I/O operations are abstracted away using a <code>Runner</code> object which represents the external environment of the MR infrastructure.</p>
<p>When an executor begins it calls the <code>Runner</code>'s <code>OperatorStart</code> function, which prepares the machinery for reading/writing files. Afterwards each worker thread in the I/O pool calls the <code>Runner</code>'s <code>CreateContext</code> to get a <code>RawContext</code> object. In order to read its inputs, the executor calls the <code>Runner</code>'s <code>ProcessInputFile</code> function, this function accepts an input path and a callback, it calls the callback repeatedly on inputs coming from the path. Finally, when an executor finishes, it calls the <code>Runner</code>'s OperatorEnd function, which closes the handles of open files as well as outputs a list of which files were written to (it's impossible to calculate this before running, due to custom sharding).</p>
<p>In the previous paragraph, <code>RawContext</code> objects were mentioned. <code>RawContext</code> is the channel connecting pipeline user code (operator implementations) to the framework. <code>RawContext</code> is handled by <code>Runner</code> and among other things it allows operators to write their outputs into files (in fact, the <code>DoContext</code> that user-written functions accept is a simple wrapper around <code>RawContext</code>). Note, however, that <code>RawContext</code>, unlike <code>Runner</code>, is not purely an abstract interface, it also contains logic to handle freq counters instead of only supporting I/O operations. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
